We use [sqlboiler](https://github.com/databrary/sqlboiler) for the models but [sqlx](http://jmoiron.github.io/sqlx/) for
one off interaction with the db (and as the sqlboiler executor).

# SQL Functions

These are just thin calls to existing sql functions in the database. They were generated by [knq/xo](https://github.com/knq/xo).

# Schema

The schema are a set of sql files that function as migrations; `0.sql` is the original schema and each of the follow
`.sql` files function as migrations. `master_sql` is the current state of database schema. Whenever you make a change to
`master_sql` you should also make a migration and apply it to the database.

# Models



## SQLBoiler Models

 is a code gen tool that generates an ORM like interface to a database
by querying the database itself and constructing the models therefrom. This is what has been used to generate the models
here. The version of sqlboiler though has been heavily modified to enable use of "custom types". The forked version is @
[makslevental/sqlboiler](https://github.com/makslevental/sqlboiler). In addition to modifying sqlboiler the templates
used to generate the source files have been modified as well. They are @ [config/sqlboiler/templates](https://github.com/databrary/databrary/tree/go_models/config/sqlboiler/templates).

On changing the schema for the database all of the models should be regenerated. Note this will require finessing since
sqlboiler and the stock templates have been heavily modified. There are plans to make this easier.

There are some models that were generated with too many ORMish methods because they're tables with schema such that
only tables that inherit said tables can be inserted into. These are all of the tables with `CHECK (false) NO INHERIT`.



### Custom Types

These are types corresponding to fields used in db models that don't have natural mappings
types in the stl (nor `sqlboiler` nor `gopkg.in/nullbio/null.v6`).

Each type has a `<type>Random()` function that is not very random. These are used to generate instances of these types
in the tests generated by sqlboiler.

Each type is tightly coupled to `sqlboiler` in that it is assigned as the field type name by `sqlboiler` in its 
[postgres driver](https://github.com/databrary/sqlboiler/blob/master/bdb/drivers/postgres.go#L349) **and** determines
whether [imports](https://github.com/databrary/sqlboiler/blob/master/boilingcore/imports.go#L310) are included correctly
for generated models.

#### Enums

The types ending in `.xo.go` are enums and were generated using [xo](https://github.com/knq/xo).

#### Inet

`Inet` corresponds to the [inet](https://www.postgresql.org/docs/9.6/static/datatype-net-types.html) postgres type.

#### Interval

`Interval` corresponds to the postgres `interval HOUR TO SECOND (3)` type. Note that postgres rounds up in the last
significant digit so an interval of `00:00:0005` is actually represented as `00:00:001` and `00:00:0004` is
actually represented as `00:00:000` . `Interval` preserves this.

Comparison operations are implemented (i.e `LT`,`LE`,`EQ`, etc.).

#### Segment

`Segment` corresponds to the `segment` type in the database, which is a [range](https://www.postgresql.org/docs/9.6/static/rangetypes.html)
over `interval`s with possibly unbounded endpoints (e.g. `(,)` is an unbounded interval on both ends).

Various comparison operations relative to endpoints are implemented (e.g. `LowerLT`, which determines whether the
lower endpoint of one interval is `LT` another). They are all defined according to comparisons on suprema, infima, i.e.
the lower endpoints of `[a,b]`, `(a,b]` are equal because the infima of those two segments are the same.

